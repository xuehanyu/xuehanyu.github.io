<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>薛涵予微笑着走向生活😊</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="薛涵予微笑着走向生活😊">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="薛涵予微笑着走向生活😊">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="薛涵予微笑着走向生活😊">
  
    <link rel="alternate" href="/atom.xml" title="薛涵予微笑着走向生活😊" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">薛涵予微笑着走向生活😊</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-git内部原理及最佳实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/09/git内部原理及最佳实践/" class="article-date">
  <time datetime="2018-08-09T10:10:13.798Z" itemprop="datePublished">2018-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/09/git内部原理及最佳实践/">Git内部原理及“最佳”实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git内部原理"><a href="#Git内部原理" class="headerlink" title="Git内部原理"></a>Git内部原理</h1><h3 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h3><ul>
<li>直接记录快照，而非差异比较<br>  Git和其他版本控制系统的主要差别在于Git对待数据的方法，其它大部分系统以文件变更列表的方式存储信息，这类系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。而Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git对待数据更像是一个快照流。</li>
</ul>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/git.png" alt="git"></p>
<ul>
<li><p>Git保证完整性<br>  Git中所有数据在存储前都计算校验和，然后以校验和来引用，Git 用以计算校验和的机制叫做 SHA-1散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：24b9da6552252987aa493b52f8696cd6d3b00373。实际上，Git数据库中保存信息都是以文件内容的哈希值来索引，而不是文件名。<br>  如何计算？<br>  Git在计算校验和时，首先会创建一个头部信息然后和原始数据拼接起来。从而计算出一个40位的hash值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = &quot;&lt;type&gt; &quot; + content.length + &quot;\0&quot;</span><br><span class="line">hash = sha1(header + content)</span><br></pre></td></tr></table></figure>
<p>  <strong>Git十分智能，你只需要提供SHA-1的前几个字符就可以获得对应的那次提交，当然你提供的SHA-1字符数量不得少于4个，并没有歧义–也就是说，当前仓库中只有一个对象以这段SHA-1开头，默认使用七个字符，通常8到10个字符就已经足够在一个项目中避免SHA-1歧义。</strong></p>
</li>
<li><p>三种状态<br>  工作目录下的每一个文件不外乎有两种状态：已跟踪（tracked）或未跟踪（Untracked）。<br>  已跟踪的文件是指那些被纳入了版本控制的文件，在上次快照中有它们的记录，工作目录中除以跟踪文件以外的所有其他文件都属于未跟踪文件，它们既不存在于上次快照记录中，也没有放入暂存区。<br>  已提交（committed）、已修改（modified）和已暂存（staged），已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。<br>  由此引入三区：Git仓库、工作目录以及暂存区。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/work.png" alt="git"><br>Git仓库: 是Git用来保存项目元数据和对象数据库的地方（.git）。</p>
<ul>
<li><p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个.git目录。 这个目录包含了几乎所有Git存储和操作的对象。该目录结构如下所示：<br><img src="http://pbv0yiork.bkt.clouddn.com/image/list.png" alt="git"></p>
<ul>
<li>config项目特有的配置选项</li>
<li>description文件仅供 GitWeb 程序使用</li>
<li>hooks包含客户端或服务端的钩子脚本</li>
<li>info包含一个全局性排除文件</li>
<li>HEAD指示目前被检出的分支(特殊的指针)</li>
<li>objects存储所有数据内容</li>
<li><p>refs存储指向分支的提交对象的指针</p>
<p><strong>index                   保存暂存区信息</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>工作目录: 是对项目的某个版本独立提取出来的内容。<br>暂存区域是一个文件，保存了下次将提交的文件列表。一般在Git仓库目录中，有时也被称作“索引”。<br>基本的git工作流程:<br>    在工作目录中修改文件<br>    暂存文件，将文件快照放入暂存区域<br>    提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</p>
<ul>
<li>三棵树<br>树 – 文件的集合，而不是特定的数据结构<br>Git作为一个系统，是以它的一般操作来管理并操纵这三颗树的：<ul>
<li>HEAD ， 上一次提交的快照，下一次提交的父节点<br>HEAD，是当前分支引用的指针，它总是指向该分支的最后一次提交，这表示HEAD将是下次提交的父节点</li>
<li>Index， 预期的下次提交快照<br>Git将上一次检出到工作目录中的所有文件填充到索引区，他们看起来就像最初被检出时的样子，之后你会将其中一些文件替换为新版本，接着通过git commit 将它们转换为树来用作新的提交。</li>
<li>Working Directory ， 工作区<br>前两颗树以一种高效但并不直观的方式，将它们的内容存储在.git文件夹中。工作目录会将它们解包为实际的文件以便编辑。<br><strong>Git主要的目的是通过操纵三棵树来以更加连续的状态记录项目的快照</strong></li>
</ul>
</li>
</ul>
<h3 id="git-是如何运转的？"><a href="#git-是如何运转的？" class="headerlink" title="git 是如何运转的？"></a>git 是如何运转的？</h3><ul>
<li><p>初始化git 仓库（git init），创建一个文件file.txt，我们称其为该文件的v1版本<br>git为我们自动创建第一个分之master，以及指向master的一个指针HEAD<br><img src="http://pbv0yiork.bkt.clouddn.com/init.png" alt="git"><br>底层命令实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;version 1&apos; &gt; test.txt </span><br><span class="line">git hash-object -w test.txt </span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure>
<p>此时，只有工作目录有内容</p>
</li>
<li><p>git add – 跟踪文件，获取工作目录中的内容，并将其复制到索引中<br><img src="http://pbv0yiork.bkt.clouddn.com/image/add.png" alt="git"><br>底层命令实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>git commit<br>首先，他会移除索引中的内容并将它保存一个永久的快照，<br>然后，创建一个指向该快照的提交对象，最后更新master来指向本次提交<br><img src="http://pbv0yiork.bkt.clouddn.com/image/commit.png" alt="git"></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;first commit&apos; | git commit-tree d8329f 	</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br></pre></td></tr></table></figure>
</li>
<li><p>对文件修改，然后提交它，会经历同样的过程<br>首先，编辑文件，版本为v2<br><img src="http://pbv0yiork.bkt.clouddn.com/image/edit.png" alt="git"><br>运行 git status， 显示changes not staged for commit – 因为索引区与工作目录之间存在不同，<br>接着，运行git add将其暂存到索引中<br><img src="http://pbv0yiork.bkt.clouddn.com/image/editadd.png" alt="git"><br>由于索引和HEAD不同，若运行git status 会看到， changes to be committed  — 下一次提交与上一次提交不同<br>最后，git commit 完成<br><img src="http://pbv0yiork.bkt.clouddn.com/image/editcommit.png" alt="git"><br>切换分支或克隆的过程也类似，当检出一个分支时，它会修改HEAD指向新的分支引用，将索引填充为该次提交的快照，然后将索引的内容复制到工作目录中。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  每次我们运行git add 、 git commit 时，Git所做的实质工作：</p>
<ul>
<li>将被改写的文件保存为数据对象</li>
<li>更新暂存区，记录树对象（通常，Git根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象）</li>
<li>最后创建一个提交对象，指明了顶层树对象（代表当前项目快照）和父提交对象（上一次的提交对象）。 </li>
</ul>
<h3 id="找不同-–-reset-和-chekcout"><a href="#找不同-–-reset-和-chekcout" class="headerlink" title="找不同 –  reset 和 chekcout"></a>找不同 –  reset 和 chekcout</h3><h2 id="reset-做了什么？"><a href="#reset-做了什么？" class="headerlink" title="reset 做了什么？"></a>reset 做了什么？</h2><p>  为了演示下面例子，再次修改了file.txt文件并第三次提交它。现在历史看起来像：<br>    <img src="http://pbv0yiork.bkt.clouddn.com/image/reset2.png" alt="git"></p>
<ul>
<li><p>移动HEAD<br>  reset做的第一件事就是移动HEAD的指向，reset移动HEAD以及其指向的分支<br><img src="http://pbv0yiork.bkt.clouddn.com/image/soft.png" alt="git"><br><strong>它本质上是撤销上一次git commit命令</strong><br>当你运行commit时，git会创建一个新的提交，并移动HEAD所指向的分之来使其指向该提交。当你将它reset回HEAD～（HEAD的父节点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录</p>
<ul>
<li>更新索引（–mixed）<br>reset会用HEAD指向的当前快照的内容来更新索引<br><img src="http://pbv0yiork.bkt.clouddn.com/image/mixed.png" alt="git"><br>如果指定–mixed 选项，reset将会在这时停止，这也是默认行为，如果没有指定任何选项（在本例中 git reset HEAD～），这就是命令将会停止的地方。<br>由图可看出，它依然回撤销上一次的提交，还会取消暂存所有的东西，于是，我们回滚倒了所有git add 和git commit 的命令执行之前。</li>
<li>更新所有工作目录 （–hard）<br>reset要做的第三件事就是让工作目录看起来像索引，如果使用–hard选项，它将会继续这一步。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/hard.png" alt="git"><br>⚠️注意：–hard标记时reset命令唯一危险用法，它也是Git会真正地销毁数据的仅有的几个操作之一。在这种特殊的情况下，Git数据库中的一个提交内还留有该文件的v3版本，我们可以通过reflog来找回它。但是若该文件还未提交，Git仍会覆盖它从而导致无法恢复</li>
<li>总结<br>reset命令会以特定的顺序重写这三棵树，在你指定一下选项时会停止；<ul>
<li>移动HEAD分支的指向（若指定 –soft，则到此停止）</li>
<li>使索引看起来像HEAD（若未指定 –hard，则到此停止）</li>
<li>使工作目录看起来像索引<h2 id="checkout-做了什么？"><a href="#checkout-做了什么？" class="headerlink" title="checkout 做了什么？"></a>checkout 做了什么？</h2></li>
</ul>
</li>
<li>git checkout – <file>  撤销修改，用暂存区的某个文件来覆盖工作区，经常用于撤销一些修改<br>实质 ： git checkout – <file> 是用来是工作区回到上次操作git add时的样子</file></file></li>
<li>git chekout HEAD <file> 是用版本库同时覆盖暂存区和工作区，用来彻底撤销一个修改，这个命令更加危险，因为它会同时修改工作区和暂存取，且无法撤销</file></li>
</ul>
<h2 id="reset-和-checkout的区别"><a href="#reset-和-checkout的区别" class="headerlink" title="reset 和 checkout的区别"></a>reset 和 checkout的区别</h2><ul>
<li>可以实现相同的功能，比如还原本地文件，但是reset更强调“撤销”，比如撤销暂存区、撤销暂存区和本地，而checkout更强调“替换”，比如用暂存区内容替换本地，用head指向目录替换暂存区和本地。</li>
<li>reset会移动HEAD分支的指向，而checkout只会移动HEAD自身来指向另一个分支。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/reset.png" alt="git"></li>
</ul>
</li>
</ul>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><p>Git的分支，其实本质上仅仅是指向提交对象的可变指针。git的默认分支是master（git init时默认创建），再多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支。它会在每次提交的操作中自动 向前移动。</p>
<ul>
<li>假设，Git仓库目前的分支及提交历史如下：<br><img src="http://pbv0yiork.bkt.clouddn.com/image/branch.png" alt="git"></li>
<li><p>如何创建分支？<br>eg： 创建test分支（创建了一个可以移动的新的指针）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test  //  这会在当前提交对象上创建一个指针</span><br></pre></td></tr></table></figure>
<p>底层命令实现：(.git/refs)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref refs/head/test sha-1</span><br></pre></td></tr></table></figure>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/branch1.png" alt="git"><br>由图可看到，有两个指向相同提交历史的分支，那么Git又是怎么知道当前在哪一个分支上呢？ – HEAD特殊指针<br>HEAD是当前分支引用的指针，它总是指向该分支上的最后一次提交，这也标示HEAD将时下一次提交的父节点。通常，理解HEAD最简单的方式，就是将它看做上一次提交的快照。<br>执行git branch test 仅仅创建了新分支，并不会自动切换倒新分支中去。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/branch2.png" alt="git"></p>
<p><strong>当运行类似于 git branch (branchname) 这样的命令时，Git 实际上会运行 update-ref 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</strong></p>
</li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test    // 这样，HEAD就指向了test分支</span><br></pre></td></tr></table></figure>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/branch3.png" alt="git"></p>
<ul>
<li>切换分支，实则是将HEAD指向所要切换的分支<br>这个命令做的三件事：<br>  将HEAD指向对应分支的最后一次commit<br>  将HEAD指向的commit里所有文件的snapshot替换掉Index区域里原来的内容（将工作目录恢复成master分支所指向的快照内容）<br>  将Index区域里的内容填充到Working Directory里<ul>
<li>底层实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-ref HEAD refs/heads/test</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Git最佳实践"><a href="#Git最佳实践" class="headerlink" title="Git最佳实践"></a>Git最佳实践</h1><h3 id="git-flow-开发流程"><a href="#git-flow-开发流程" class="headerlink" title="git flow 开发流程"></a>git flow 开发流程</h3><p><img src="http://pbv0yiork.bkt.clouddn.com/image/flow.png" alt="git"></p>
<ul>
<li>Git flow 使用原则<br>  Master分支是线上稳定分支，Release通常用作测试分支，Develop分支是开发应用的主分支<br>  所有的功能开发都在Feature分支进行，然后合并到Develop分支<br>  Release分支发布后出现问题，直接在Release分支修改，避免Develop分支代码污染</li>
</ul>
<h3 id="规范git的使用"><a href="#规范git的使用" class="headerlink" title="规范git的使用"></a>规范git的使用</h3><ul>
<li>尽早并频繁地提交改动<br>经常性地提交改动可以确保不会出现特别庞大的提交，同时也可以比较精准地对应到所需要的改动上。此外，通过频繁地提交也可以比较快速地和其他开发人员来共享你的改动。同样也会避免在整合代码时出现过多的合并冲突。相反的，非常庞大的提交会加大整合代码时出现冲突的风险，解决这些冲突也会非常复杂。</li>
<li>提交对应改动<br>一次提交要包括一个相关改动。例如，对于两个错误的修复应该进行两次不同的提交。精简的提交可以让其他的开发团队人员更简单地明白其改动的用义。如果其中一次提交的改动出现了问题，也可以方便地回滚到改动之前的状态。借助暂存功能来标记相关的改动文件，Git 可以为你打造出非常精准的提交。</li>
<li>提交前测试那些改动<br>不要理所当然地认为自己完成的改动都是正确的。所有的改动一定要通过彻底地测试才表示它真正地被完成了。尽管这些改动可能仅仅是提交到了你的本地仓库中，只有你自己才能看到，但完整的测试同样是非常重要的，因为这些代码可能之后会被推送和共享到远程给其他的开发人员。</li>
<li><p>Don’t panic<br>只要你已经完成了你的工作（或者在许多情况下甚至已经添加了它git add），你的工作将不会丢失至少两周，运行命令手动清除它</p>
<!-- As long as you have committed your work (or in many cases even added it with git add) your work will not be lost for at least two weeks unless you really work at it (run commands that manually purge it).
When attempting to find your lost commits, first make sure you will not lose any current work. You should commit or stash your current work before performing any recovery efforts that might destroy your current work and perhaps take backups of it (see Backups below). After finding the commits you can reset, rebase, cherry-pick, merge, or otherwise do what is necessary to get the commit history and work tree you desire. -->
<ul>
<li><p>有三个地方可以隐藏“丢失”的变化</p>
<ul>
<li>reflog<br>Git reflog 可以查看所有分支的所有操作记录（包括提交、回退、已删除的提交操作记录等)</li>
<li>lost＆found（git fsck –unreachable）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck --lost-found</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过该命令你可以看到丢掉的提交。你可以通过运行 git show [commit_hash] 查看提交之后的改变或者运行git merge [commit_hash] 来恢复到之前的提交。<br>git fsck 相对reflog是有优势的。比方说你删除一个远程的分支然后关闭仓库。 用fsck 你可以搜索和恢复已删除的远程分支</p>
<ul>
<li><p>stashed（git stash list）<br>你正在修改某个bug或者某个特性，又突然被要求展示你的工作。而你现在所做的工作还不足以提交，这个阶段你还无法进行展示（不能回到更改之前）。在这种情况下， git stash可以帮助你。stash在本质上会取走所有的变更并存储它们为以备将来使用。stash你的变更，你只需简单地运行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>希望检查stash列表，你可以运行下面的命令：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>  如果你想要解除stash并且恢复未提交的变更，你可以进行apply stash:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>
<p>  每个stash都有一个标识符，一个唯一的号码,如果你只想留有余地进行apply stash，你应该给apply添加特定的标识符：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;2&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高质量的提交注释<br><a href="https://segmentfault.com/a/1190000009048911" target="_blank" rel="noopener">超链接名</a></p>
</li>
<li><p>不要提交不完整的改动<br>虽然原则上来说不要提交一些还没有完成的改动，但是对于一个非常庞大的新功能来说，也并不意味着你必须整体完成这个功能后才可以提交。恰恰相反，你必须把那些改动正确地分割成一些有意义的逻辑模块来进行频繁地提交。如果你仅仅是因为急着想要下班，或者是想要得到一个干净的工作副本（比如想要切换到另一个分支上），你可以利用 Git 所提供的储藏（Stash）功能来解决这些问题。切记不要把那些不完整的改动提交到仓库中</p>
</li>
<li><p>Release tagging  – 打tag</p>
</li>
<li>使用有用的工具<br>强烈安利sourceTree</li>
</ul>
<h3 id="推荐git相关内容"><a href="#推荐git相关内容" class="headerlink" title="推荐git相关内容"></a>推荐git相关内容</h3><p><a href="https://bingohuang.gitbooks.io/progit2/content/" target="_blank" rel="noopener">Pro Git</a><br><a href="http://sethrobertson.github.io/GitBestPractices/" target="_blank" rel="noopener">Git 最佳实践</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/09/git内部原理及最佳实践/" data-id="cjmlppnjg0005qafyc7pwkr6r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js基础——原始值的包装对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/29/js基础——原始值的包装对象/" class="article-date">
  <time datetime="2018-07-29T14:52:32.909Z" itemprop="datePublished">2018-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/29/js基础——原始值的包装对象/">JS基础—-原始值的包装对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>布尔值、数字和字符串这三种原始值都有对应的构造函数：Boolean、Number、string。</p>
<h3 id="作为构造函数，他们创建的对象和它们包装的原始值有很大的不同"><a href="#作为构造函数，他们创建的对象和它们包装的原始值有很大的不同" class="headerlink" title="作为构造函数，他们创建的对象和它们包装的原始值有很大的不同"></a>作为构造函数，他们创建的对象和它们包装的原始值有很大的不同</h3><p>eg: 类型不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof new String(&apos;abc&apos;)   //  object  </span><br><span class="line">new String(&apos;abc&apos;) === &apos;abc&apos;   // false</span><br></pre></td></tr></table></figure></p>
<h3 id="作为函数，它们会将值转换为对应的原始值"><a href="#作为函数，它们会将值转换为对应的原始值" class="headerlink" title="作为函数，它们会将值转换为对应的原始值"></a>作为函数，它们会将值转换为对应的原始值</h3><p>eg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(1)      //  1</span><br></pre></td></tr></table></figure></p>
<h2 id="原始值的包装与去包装"><a href="#原始值的包装与去包装" class="headerlink" title="原始值的包装与去包装"></a>原始值的包装与去包装</h2><p>在日常的开发实践中，我们经常对原始值 如字符串 、数值进行“.”的操作，调用其方法或属性，在调用的背后就发生了包装与去包装的过程。</p>
<h3 id="通过调用包装构造函数对原始值进行包装，包装成临时对象可以调用方法或者属性："><a href="#通过调用包装构造函数对原始值进行包装，包装成临时对象可以调用方法或者属性：" class="headerlink" title="通过调用包装构造函数对原始值进行包装，包装成临时对象可以调用方法或者属性："></a>通过调用包装构造函数对原始值进行包装，包装成临时对象可以调用方法或者属性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Boolean(true)</span><br><span class="line">new String(&apos;123&apos;)</span><br><span class="line">new Number(134)</span><br></pre></td></tr></table></figure>
<h3 id="通过调用valueOf-来对原始值进行去包装，所有的对象都有这个方法，转换为原始值。"><a href="#通过调用valueOf-来对原始值进行去包装，所有的对象都有这个方法，转换为原始值。" class="headerlink" title="通过调用valueOf() 来对原始值进行去包装，所有的对象都有这个方法，转换为原始值。"></a>通过调用valueOf() 来对原始值进行去包装，所有的对象都有这个方法，转换为原始值。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Boolean(true).valueOf()        //true</span><br><span class="line">new String(&apos;123&apos;).valueOf()       // &apos;123&apos;</span><br><span class="line">new Number(134).valueOf()       // 134</span><br></pre></td></tr></table></figure>
<p>注意：将包装对象转换为原始值时只能正确地提取数字和字符串，而布尔值不能。<br><code>Boolean(new Boolean(true))</code>    //  true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/29/js基础——原始值的包装对象/" data-id="cjmlppnj00002qafye6q2w4bh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js基础——语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/js基础——语法/" class="article-date">
  <time datetime="2018-07-22T13:57:57.372Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/js基础——语法/">JS基础——语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="语法概述"><a href="#语法概述" class="headerlink" title="语法概述"></a>语法概述</h1><h2 id="下面是值的类型"><a href="#下面是值的类型" class="headerlink" title="下面是值的类型"></a>下面是值的类型</h2><h3 id="五种基本类型"><a href="#五种基本类型" class="headerlink" title="五种基本类型"></a>五种基本类型</h3><ul>
<li>字符串<br>  ‘hello’<br>  “hello”</li>
<li>数字<br>  1.234<br>  1234</li>
<li>布尔值<br>  true<br>  false</li>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="复杂数据类型-Object"><a href="#复杂数据类型-Object" class="headerlink" title="复杂数据类型-Object"></a>复杂数据类型-Object</h3><h2 id="下面是几个基础语法的例子"><a href="#下面是几个基础语法的例子" class="headerlink" title="下面是几个基础语法的例子"></a>下面是几个基础语法的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x     //  声明一个变量x </span><br><span class="line">x = 3 + z   //  给变量x赋值</span><br><span class="line">foo(a,b)   //  函数foo调用并传入形参a,b</span><br><span class="line">obj.baz(3)   //  对象的方法调用</span><br><span class="line">// 条件语句</span><br><span class="line">if（x===2）&#123;  // 判断x与2是否相等</span><br><span class="line">  x=234  </span><br><span class="line">&#125;</span><br><span class="line">//  函数生命 , 变量为a,b</span><br><span class="line">function(a,b)&#123;</span><br><span class="line">  return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式将会产生一个值，它可以出现在任何需要值的地方，如<br>x + 10<br>foo（2，4）</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句表示一种行为，如if语句、循环语句，一个程序基本上就是一个语句的序列。</p>
<p><strong> 注：凡是js期望语句的地方都可以写表达式，这样的语句叫做表达式语句。反之则不然，不能在需要表达式的地方适用语句，如判断语句不能成为函数的参数 </strong></p>
<h3 id="条件语句与条件表达式（某些情况下可以互通）"><a href="#条件语句与条件表达式（某些情况下可以互通）" class="headerlink" title="条件语句与条件表达式（某些情况下可以互通）"></a>条件语句与条件表达式（某些情况下可以互通）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  使用条件语句</span><br><span class="line">  if(score&gt;60)&#123;</span><br><span class="line">    str = &apos;及格&apos;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    str = &apos;不及格&apos;</span><br><span class="line">  &#125;</span><br><span class="line">//  如用条件表达式如下 （条件运算符或三元表达式）</span><br><span class="line">  str = score &gt; 60 ? &apos;及格&apos; : &apos;不及格&apos;</span><br></pre></td></tr></table></figure>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>ES5 提供了严格模式，在严格模式中，JavaScript代码会更加简洁，会有更少不安全的特性，更多的警告和更加合理的代码。普通模式（非严格模式），有时也被成为“宽松模式”。</p>
<h2 id="启用严格模式"><a href="#启用严格模式" class="headerlink" title="启用严格模式"></a>启用严格模式</h2><p>可以在JavaScript文件或者script标签中的第一行加入以下代码来启动严格模式<br><code>&#39;use strict&#39;</code><br>或者可以在函数作用域中启用严格模式<br><code>function foo(){
    &#39;use strict&#39;
    ...
  }</code></p>
<h3 id="严格模式中变量必须背声明"><a href="#严格模式中变量必须背声明" class="headerlink" title="严格模式中变量必须背声明"></a>严格模式中变量必须背声明</h3><p>在严格模式中，所有变量必须被显示声明，在宽松模式中，未显示声明的变量将会创建一个全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 宽松模式</span><br><span class="line">  function foo()&#123;</span><br><span class="line">    x = 111</span><br><span class="line">  &#125;</span><br><span class="line">  foo()   //  创造了一个全局变量x</span><br><span class="line">  console.log(x)   //  111;</span><br><span class="line">//  严格模式</span><br><span class="line">function foo()&#123;</span><br><span class="line"> &apos;use strict&apos;</span><br><span class="line">  x = 111</span><br><span class="line">&#125;</span><br><span class="line">foo()   //  抛出异常， ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p>
<h3 id="函数必须在作用域的顶部声明"><a href="#函数必须在作用域的顶部声明" class="headerlink" title="函数必须在作用域的顶部声明"></a>函数必须在作用域的顶部声明</h3><p>在严格模式中，所有的函数必须在顶级作用域声明，这意味着你不能在一个块内声明函数，如果这样做，将会抛出描述性错误SyntaxError；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  &apos;use strict&apos;</span><br><span class="line">  &#123;</span><br><span class="line">    // SyntaxError；</span><br><span class="line">    function bar()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">  &apos;use strict&apos;</span><br><span class="line">  &#123;</span><br><span class="line">    //  OK</span><br><span class="line">    var bar = function ()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="无方法的函数中-this的值为undefined"><a href="#无方法的函数中-this的值为undefined" class="headerlink" title="无方法的函数中 this的值为undefined"></a>无方法的函数中 this的值为undefined</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在宽松模式中</span><br><span class="line">  function foo()&#123;</span><br><span class="line">    console.log(this===window)   // true</span><br><span class="line">  &#125;</span><br><span class="line">//  在严格模式中</span><br><span class="line">function foo()&#123;</span><br><span class="line">  &apos;use strict&apos;</span><br><span class="line">  console.log(this===undefined)   // true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在严格模式中，设置或删除不可改变的属性会抛出异常"><a href="#在严格模式中，设置或删除不可改变的属性会抛出异常" class="headerlink" title="在严格模式中，设置或删除不可改变的属性会抛出异常"></a>在严格模式中，设置或删除不可改变的属性会抛出异常</h3><p>严格模式中，对属性的非法操作会抛出异常。如，对只读属性的设定操作会抛出一场，同样不可以删除不可配置的属性，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  str.length = 8  //  静默失败</span><br><span class="line">  console.log(str.length)  //  5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  &apos;use strict&apos;</span><br><span class="line">  str.length = 8  //  抛出异常 TypeError: Cannot assign to read only property &apos;length&apos; of string &apos;hello&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在严格模式中，不合格标识符不能删除"><a href="#在严格模式中，不合格标识符不能删除" class="headerlink" title="在严格模式中，不合格标识符不能删除"></a>在严格模式中，不合格标识符不能删除</h3><p>在宽松模式中，可以用下面的方式删除全局变量foo<br>delete foo<br>在严格模式中，想要删除不合格标识符时将会抛出异常，但是可以通过以下方式进行删除全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete window.foo //  浏览器</span><br><span class="line">delete global.foo  //  Node.js</span><br><span class="line">delete this.foo  //  全局作用域</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/22/js基础——语法/" data-id="cjmlppnj40004qafyehoq7qgh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-copyObj" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/14/copyObj/" class="article-date">
  <time datetime="2018-07-14T14:14:56.456Z" itemprop="datePublished">2018-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/14/copyObj/">浅复制（浅拷贝）和深复制（深拷贝）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>JS中对象分为基本类型和复合（引用）类型，基本类型存放在栈内存，复合（引用）类型存放在堆内存。<br>堆内存用于存放由new创建的对象，栈内存存放一些基本类型的变量和对象的引用变量。<br>浅拷贝：仅仅复制对象的引用，而不是对象本身；<br>深拷贝：把复制的对象所引用的全部对象都复制一遍</p>
<h3 id="对于简单变量，内存小，直接复制而不会发生引用"><a href="#对于简单变量，内存小，直接复制而不会发生引用" class="headerlink" title="对于简单变量，内存小，直接复制而不会发生引用"></a>对于简单变量，内存小，直接复制而不会发生引用</h3><p>eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 123</span><br><span class="line">Var b = a</span><br><span class="line">a = 123456</span><br><span class="line">Console.log(a).  // 123456</span><br><span class="line">Console.log(b).  // 123</span><br></pre></td></tr></table></figure></p>
<h3 id="引用只发生在对象身上，如数组、对象"><a href="#引用只发生在对象身上，如数组、对象" class="headerlink" title="引用只发生在对象身上，如数组、对象"></a>引用只发生在对象身上，如数组、对象</h3><p>（一）数组<br>浅拷贝eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1,2,3]</span><br><span class="line">Var arr2 = arr1 </span><br><span class="line">arr1.push(4)</span><br><span class="line">Console.log(arr1).  // [1,2,3,4]</span><br><span class="line">Console.log(arr2) //[1,2,3,4]</span><br><span class="line">arr2.push(6) </span><br><span class="line">Console.log(arr1).  // [1,2,3,4,6]</span><br><span class="line">Console.log(arr2) //[1,2,3,4,6]</span><br></pre></td></tr></table></figure></p>
<p>深拷贝的方法:<br>eg1:    Array.from<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Var arr3 = [1,3,5,7]</span><br><span class="line">var arr4 = Array.from(arr3)</span><br><span class="line">arr3.push(9)</span><br><span class="line">Console.log(arr3).  // [1,3,5,7,9]</span><br><span class="line">Console.log(arr4) //[1,3,5,7]</span><br></pre></td></tr></table></figure></p>
<p>eg2: …运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr5 = [2,4,6,8]</span><br><span class="line">Var arr6 = […arr5]</span><br><span class="line">arr5.push(10)</span><br><span class="line">Console.log(arr5).    // [2,4,6,8,10]</span><br><span class="line">Console.log(arr6).     // [2,4,6,8]</span><br></pre></td></tr></table></figure></p>
<p>eg3 : Array.map()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr7 = [2,3,5,6]</span><br><span class="line">Var arr8 = arr7.map(item =&gt; &#123; return item &#125;)</span><br><span class="line">arr7.push(8)</span><br><span class="line">Console.log(arr7).  // [2,3,5,6,8]</span><br><span class="line">Console.log(arr8).  // [2,3,5,6]</span><br></pre></td></tr></table></figure></p>
<p>eg4: 通过循环来控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr9 = [1,2,3,4,5]</span><br><span class="line">var arr10 = []</span><br><span class="line">for(var I=0;i&lt;arr9.length;i++)&#123; arr10[i] = arr9[i] &#125;</span><br><span class="line">arr9.push(6)</span><br><span class="line">Console.log(arr9).     // [1,2,3,4,5,6]</span><br><span class="line">Console.log(arr10).    //. [1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="浅拷贝的实现："><a href="#浅拷贝的实现：" class="headerlink" title="浅拷贝的实现："></a>浅拷贝的实现：</h3><p>eg1: 直接赋值<br>eg2: Object.assign({}, target)<br>eg3: for in循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function simpleClone(initalObj) &#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    for ( var i in initalObj) &#123;</span><br><span class="line">        obj[i] = initalObj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝的实现：<br>eg1:JSON.parse<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(initalObj) &#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        obj = JSON.parse(JSON.stringify(initalObj));</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>eg2: 递归思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj1,obj2)&#123;</span><br><span class="line">  var obj2=obj2||&#123;&#125;; //最初的时候给它一个初始值=它自己或者是一个json</span><br><span class="line">  for(var name in obj1)&#123;</span><br><span class="line">      if(typeof obj1[name] === &quot;object&quot;)&#123; //先判断一下obj[name]是不是一个对象</span><br><span class="line">          obj2[name]= (obj1[name].constructor===Array)?[]:&#123;&#125;; //我们让要复制的对象的name项=数组或者是json</span><br><span class="line">          deepClone(obj1[name],obj2[name]); //然后来无限调用函数自己 递归思想</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          obj2[name]=obj1[name];  //如果不是对象，直接等于即可，不会发生引用。</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj2; //然后在把复制好的对象给return出去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>eg3: Object.create()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(initalObj, finalObj) &#123;</span><br><span class="line">    var obj = finalObj || &#123;&#125;;</span><br><span class="line">    for (var i in initalObj) &#123;</span><br><span class="line">        var prop = initalObj[i];</span><br><span class="line">  </span><br><span class="line">        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span><br><span class="line">        if(prop === obj) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        if (typeof prop === &apos;object&apos;) &#123;</span><br><span class="line">            obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj[i] = prop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/14/copyObj/" data-id="cjmlppniv0000qafyf0pn1ecn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/09/git内部原理及最佳实践/">Git内部原理及“最佳”实践</a>
          </li>
        
          <li>
            <a href="/2018/07/29/js基础——原始值的包装对象/">JS基础—-原始值的包装对象</a>
          </li>
        
          <li>
            <a href="/2018/07/22/js基础——语法/">JS基础——语法</a>
          </li>
        
          <li>
            <a href="/2018/07/14/copyObj/">浅复制（浅拷贝）和深复制（深拷贝）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>